esphome:
  name: gate
  friendly_name: Gate
  includes:
    - gate_auth.h

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
  services:
    - service: add_authorized_code
      variables:
        code: string
        name: string
      then:
        - lambda: |
            add_authorized_code(code, name);
    - service: add_authorized_tag
      variables:
        tag: string
        name: string
      then:
        - lambda: |
            add_authorized_tag(tag, name);
    - service: remove_authorized_code
      variables:
        code: string
      then:
        - lambda: |
            remove_authorized_code(code);
    - service: remove_authorized_tag
      variables:
        tag: string
      then:
        - lambda: |
            remove_authorized_tag(tag);
    - service: clear_all_codes
      then:
        - lambda: |
            clear_all_codes();
    - service: clear_all_tags
      then:
        - lambda: |
            clear_all_tags();

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret ap_ssid
    password: !secret ap_password

captive_portal:

# Global variables for storing gate settings
globals:
  - id: gate_action_duration
    type: int
    restore_value: yes
    initial_value: '200'
  - id: last_auth_user
    type: std::string
    restore_value: yes
    initial_value: '"Unknown"'
  - id: enroll_mode_enabled
    type: bool
    restore_value: yes
    initial_value: 'false'
  # Persistent storage for authorized codes (stored as comma-separated strings)
  - id: stored_codes
    type: std::string
    restore_value: yes
    initial_value: '""'
  - id: stored_tags
    type: std::string
    restore_value: yes
    initial_value: '""'

# Output for buzzer feedback
output:
  - platform: ledc
    pin: GPIO32
    id: buzzer_output

# RTTTL for audio feedback
rtttl:
  output: buzzer_output

# Gate control relays
switch:
  - platform: gpio
    name: "Gate Open Relay"
    id: gate_open_relay
    pin: GPIO25
    internal: true
  
  - platform: gpio
    name: "Gate Close Relay" 
    id: gate_close_relay
    pin: GPIO26
    internal: true

  - platform: gpio
    pin: GPIO33
    id: keypad_led
    internal: true

  - platform: template
    name: "Enroll Mode"
    id: enroll_mode
    icon: "mdi:key-chain-variant"
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: CONFIG
    turn_on_action:
      - lambda: |
          ESP_LOGI("AUTH", "Enroll mode enabled");
          id(enroll_mode_enabled) = true;
    turn_off_action:
      - lambda: |
          ESP_LOGI("AUTH", "Enroll mode disabled");
          id(enroll_mode_enabled) = false;

# Buttons for opening or closing
button:
  - platform: template
    name: "Open Gate"
    id: gate_open_button
    on_press:
      - switch.turn_on: gate_open_relay
      - delay: !lambda "return id(gate_action_duration);"
      - switch.turn_off: gate_open_relay

  - platform: template
    name: "Close Gate"
    id: gate_close_button
    on_press:
      - switch.turn_on: gate_close_relay
      - delay: !lambda "return id(gate_action_duration);"
      - switch.turn_off: gate_close_relay
  
  - platform: template
    name: "Clear All Codes"
    id: clear_all_codes_button
    entity_category: CONFIG
    on_press:
      - lambda: |
          ESP_LOGI("AUTH", "Clearing all authorized codes");
          clear_all_codes();
          clear_all_tags();

# Gate sensor and status indicators
binary_sensor:
  - platform: gpio
    name: "Gate Sensor"
    id: gate_sensor
    pin: 
      number: GPIO27
      mode: INPUT_PULLUP
    device_class: door
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_state:
      - lambda: |
          if (x) {
            id(gate).publish_state("OPEN");
          } else {
            id(gate).publish_state("CLOSED");
          }

cover:
  - platform: template
    name: "Gate"
    id: gate
    device_class: door
    icon: "mdi:gate"
    open_action:
      - button.press: gate_open_button
    close_action:
      - button.press: gate_close_button
    stop_action:
      - switch.turn_off: gate_open_relay
      - switch.turn_off: gate_close_relay
    

# Text sensors for status display
text_sensor:   
  - platform: template
    name: "Last Authenticated User"
    id: last_user
    icon: "mdi:account-check"
    
  - platform: template
    name: "Last Code Entered"
    id: last_code_entered
    icon: "mdi:numeric"

# Number input for gate open duration
number:
  - platform: template
    name: "Gate Action Duration"
    id: gate_action_duration_input
    icon: "mdi:timer"
    min_value: 1000
    max_value: 10000
    step: 500
    unit_of_measurement: "ms"
    mode: box
    set_action:
      - globals.set:
          id: gate_action_duration
          value: !lambda "return (int)x;"
      - lambda: ESP_LOGI("CONFIG", "Gate open duration set to %d ms", (int)x);
    entity_category: CONFIG

# Key collector for PIN codes
key_collector:
  - id: pin_collector
    source_id: gate_wiegand
    min_length: 6
    max_length: 6
    end_keys: "#"
    end_key_required: false
    clear_keys: "*"
    allowed_keys: "0123456789"
    timeout: 10s
    on_progress:
      - lambda: |
          ESP_LOGI("PIN", "PIN entry progress: %s", x.c_str());
    on_result:
      - lambda: |
          ESP_LOGI("PIN", "PIN entered: %s", x.c_str());
          std::string pin_code = x;
          id(last_code_entered).publish_state(pin_code);

          if (id(enroll_mode_enabled)) {
            add_authorized_code(pin_code, "Unknown");
            id(enroll_mode_enabled) = false;
            ESP_LOGI("AUTH", "Code enrolled: %s, disabled enroll mode", pin_code.c_str());

            // Success beep
            id(buzzer_output).set_frequency(1000);
            id(buzzer_output).set_level(0.5);
            id(buzzer_output).turn_on();
          } else if (check_authorized_code(pin_code)) {
            std::string user_name = get_code_user_name(pin_code);
            ESP_LOGI("AUTH", "Valid PIN code entered by: %s", user_name.c_str());
            id(last_auth_user) = user_name;
            id(last_user).publish_state(user_name);
            
            // Control gate based on current state
            if (id(gate_sensor).state) {  // Gate is closed
              id(gate_open_button).press();
              ESP_LOGI("GATE", "Opening gate for authorized user: %s", user_name.c_str());
            } else {  // Gate is open
              id(gate_close_button).press();
              ESP_LOGI("GATE", "Closing gate for authorized user: %s", user_name.c_str());
            }
            
            // Success beep
            id(buzzer_output).set_frequency(1000);
            id(buzzer_output).set_level(0.5);
            id(buzzer_output).turn_on();
          } else {
            ESP_LOGW("AUTH", "Invalid PIN code entered: %s", pin_code.c_str());
            id(last_user).publish_state("Invalid Code");
            
            // Error beep pattern
            for (int i = 0; i < 3; i++) {
              id(buzzer_output).set_frequency(500);
              id(buzzer_output).set_level(0.3);
              id(buzzer_output).turn_on();
              delay(200);
              id(buzzer_output).turn_off();
              delay(100);
            }
          }
    on_timeout:
      - lambda: |
          ESP_LOGI("PIN", "PIN entry timeout");

# Wiegand interface
wiegand:
  - id: gate_wiegand
    d0: GPIO18   # connect DATA0 here
    d1: GPIO19   # connect DATA1 here

    on_key:
      - lambda: |
          ESP_LOGI("KEY", "Key pressed: %d", x);
          
    on_tag:
      - lambda: |
          ESP_LOGI("TAG", "Tag scanned: %s", x.c_str());
          std::string tag_id = x;

          if (id(enroll_mode_enabled)) {
            add_authorized_tag(tag_id, "Unknown");
            id(enroll_mode_enabled) = false;
            ESP_LOGI("AUTH", "Tag enrolled: %s, disabled enroll mode", tag_id.c_str());

            // Success beep
            id(buzzer_output).set_frequency(1000);
            id(buzzer_output).set_level(0.5);
            id(buzzer_output).turn_on();
          } else if (check_authorized_tag(tag_id)) {
            std::string user_name = get_tag_user_name(tag_id);
            ESP_LOGI("AUTH", "Valid tag scanned by: %s", user_name.c_str());
            id(last_auth_user) = user_name;
            id(last_user).publish_state(user_name);
            
            // Control gate based on current state
            if (id(gate_sensor).state) {  // Gate is closed
              id(gate_open_button).press();
              ESP_LOGI("GATE", "Opening gate for authorized user: %s", user_name.c_str());
            } else {  // Gate is open
              id(gate_close_button).press();
              ESP_LOGI("GATE", "Closing gate for authorized user: %s", user_name.c_str());
            }
            
            // Success beep
            id(buzzer_output).set_frequency(1000);
            id(buzzer_output).set_level(0.5);
            id(buzzer_output).turn_on();
          } else {
            ESP_LOGW("AUTH", "Invalid tag scanned: %s", tag_id.c_str());
            id(last_user).publish_state("Invalid Tag");
            
            // Error beep pattern
            for (int i = 0; i < 3; i++) {
              id(buzzer_output).set_frequency(500);
              id(buzzer_output).set_level(0.3);
              id(buzzer_output).turn_on();
              delay(200);
              id(buzzer_output).turn_off();
              delay(100);
            }
          }
          
          
    on_raw:
      - lambda: |
          ESP_LOGI("RAW", "Raw data: %d bits, value %llx", bits, value);